== Introduction ==

Imitation is the sincerest form of flattery. In that spirit, we decided to create an implementation of of the templating language used by the [http://www.djangoproject.com/ Django Project] in Java using SableCC. While we cannot claim any points for originality in coming up with a project idea, creating an alternate implementation of a language presented us with the opportunity to explore the strengths and weaknesses of each implementation.

One point of comparison between the two approaches is the method of parsing employed. Our implementation makes use of a SableCC grammar to generate a language recognizer. In contrast, Django makes use of the regular expression support available in Python to perform parsing. One drawback to the SableCC approach is the lack of support for exception throwing in SableCC. Bailing out of a parse requires resorting to throwing RuntimeExceptions, which need not be declared in a method's signature to be thrown. Additionally, it lacks the error production mechanisms available in Yacc/Bison that allow more robust error handling to be embedded into the grammar itself. The advantage that using SableCC has over the python implementation is that there is a clearer separation between the language recognition constructs used in SableCC's lexer and parser, than in regular expressions, which must perform a double-duty of parsing and lexing.

=== Challenges ===

One of the most difficult and daunting tasks was implementing template inheritance. Template inheritance allows you to define blocks within a template which can later be overridden or extended. Dealing with document inheritance meant that we needed to be able to recursively load documents while keeping track of document blocks. We realized that at an abstract level, each template is comprised of two types of "fragments": text, and blocks (of fragments). The processing flow is as follows: when processing a fragment (either text or a block) add the fragment to the current block on the document fragment stack. There are some exceptions though. If a block of the same name has already been defined in the current document, then it is invalid. If a block of the same name exists in any of the parent document, and if the block is a top-level fragment of the current document, then it will replace the block within the parent. Otherwise, if a block of the same name does not exist in a parent document, then it gets rendered normally, and is pushed onto the fragment stack.

Another hurdle to be overcome was learning to use the lexer states feature available in SableCC. Because the template language essentially embeds one language within a stream of raw data, the lexer needed to be manipulated to pass the raw data through unchanged, while recognizing the language embedded within the stream of data.



TODO: discuss
  * Challenge of implementing extends
  * Usage of SableCC parser states
  * Things that make you go hmm??